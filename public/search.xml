<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git常用的撤销操作]]></title>
    <url>%2Funcategorized%2Fgitrevoke%2F</url>
    <content type="text"><![CDATA[Git各个状态之间转换指令总结 基本状态标识 A- = untracked 未跟踪 A = tracked 已跟踪未修改 A+ = modified - 已修改未暂存 B = staged - 已暂存未提交 C = committed - 已提交未PUSH 各状态之间变化 A- -&gt; B : git add &lt;FILE&gt; B -&gt; A- : git rm --cached &lt;FILE&gt; B -&gt; 删除不保留文件 : git rm -f &lt;FILE&gt; A -&gt; A- : git rm --cached &lt;FILE&gt; A -&gt; A+ : 修改文件 A+ -&gt; A : git checkout -- &lt;FILE&gt; A+ -&gt; B : git add &lt;FILE&gt; B -&gt; A+ : git reset HEAD &lt;FILE&gt; B -&gt; C : git commit C -&gt; B : git reset --soft HEAD^ 修改最后一次提交:git commit --amend (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https'){ bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else{ bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
      <tags>
        <tag>git</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字识别 baidu-ocr-nodejs]]></title>
    <url>%2Funcategorized%2Fbaidu-ocr-nodejs%2F</url>
    <content type="text"><![CDATA[👓 Baidu OCR Api For Node Advantages 支持本地图片 外部图片(速度取决图片大小) 识别简单的验证码 平时相机拍摄书本的文字,基本能达到 95% 支持 shell/nodejs 全局安装可在控制台直接运行 bluebird/promise 接口操作灵活 Install &amp; Usage1. Global123456789npm install baidu-ocr-api -gocr --help# 远程图片ocr http://7pun4e.com1.z0.glb.clouddn.com/test.jpg# 本地图片ocr ./test.jpg 效果图 的早期世界观是建立在《魔兽争霸3：冰封王座》的基础上的，因此与现在暴雪公司的《魔兽世界》的背景设定有一定的联系，但由于版本更迭又略有不同。整个地图中地形名费伍德森林，费伍德森林是网络游戏《魔兽世界》中的游戏地图，位于卡利姆多境内的一片森林。这片由森林和草场构成的繁荣动荡的土地曾经由卡尔多雷掌管，并曾经处于半神塞纳留斯的保护下。燃烧军团的铁蹄践踏了这片土地，没有被毁灭的树木和生物则被恶魔的暴行永远的诅咒着 2. Nodejs1npm install baidu-ocr-api --save FYI examples 123456789101112131415161718/**登陆 百度bcs控制台中心 申请access keyhttps://console.bce.baidu.com/iam/#/iam/accesslist**/var ak = 'your ak';var sk = 'your sk';var ocr = require('baidu-ocr-api').create(ak,sk);// 外部图片ocr.scan(&#123; url:'http://7pun4e.com1.z0.glb.clouddn.com/test.jpg', // 支持本地路径 type:'text',&#125;).then(function (result) &#123; return console.log(result)&#125;).catch(function (err) &#123; console.log('err', err);&#125;) Test12make testmake cov # Coverage rate License MIT]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ueditor:nodejs]]></title>
    <url>%2Fnodejs%2Fueditor-nodejs%2F</url>
    <content type="text"><![CDATA[UEditor 官方支持的版本有PHP JSP ASP .NET.ueditor for nodejs 可以让你的UEditor支持nodejs ueditor@1.0.0 已经全面升级 。github地址 ##Installation 1npm install ueditor --save ##Usage 1234567891011121314151617181920212223242526272829303132333435363738var bodyParser = require('body-parser')var ueditor = require("ueditor")app.use(bodyParser.urlencoded(&#123; extended: true&#125;))app.use(bodyParser.json());// /ueditor 入口地址配置 https://github.com/fex-team/ueditor/blob/dev-1.5.0/ueditor.config.js// 官方例子是这样的 serverUrl: URL + "php/controller.php"// 我们要把它改成 serverUrl: URLapp.use("/ueditor", ueditor(path.join(__dirname, 'public'), function(req, res, next) &#123; // ueditor 客户发起上传图片请求 if(req.query.action === 'uploadimage')&#123; // 这里你可以获得上传图片的信息 var foo = req.ueditor; console.log(foo.filename); // exp.png console.log(foo.encoding); // 7bit console.log(foo.mimetype); // image/png // 下面填写你要把图片保存到的路径 （ 以 path.join(__dirname, 'public') 作为根路径） var img_url = 'yourpath'; res.ue_up(img_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 &#125; // 客户端发起图片列表请求 else if (req.query.action === 'listimage')&#123; var dir_url = 'your img_dir'; // 要展示给客户端的文件夹路径 res.ue_list(dir_url) // 客户端会列出 dir_url 目录下的所有图片 &#125; // 客户端发起其它请求 else &#123; res.setHeader('Content-Type', 'application/json'); // 这里填写 ueditor.config.json 这个文件的路径 res.redirect('/ueditor/ueditor.config.json&#125;&#125;)); ##Example12345678910111213141516171819202122232425262728var bodyParser = require('body-parser')var ueditor = require("ueditor")app.use(bodyParser.urlencoded(&#123; extended: true&#125;))app.use(bodyParser.json());app.use("/ueditor", ueditor(path.join(__dirname, 'public'), function(req, res, next) &#123; // ueditor 客户发起上传图片请求 if(req.query.action === 'uploadimage')&#123; var foo = req.ueditor; var date = new Data(); var imgname = req.ueditor.filename; var img_url = '/images/ueditor/'; res.ue_up(img_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 &#125; // 客户端发起图片列表请求 else if (req.query.action === 'listimage')&#123; var dir_url = '/images/ueditor/'; res.ue_list(dir_url); // 客户端会列出 dir_url 目录下的所有图片 &#125; // 客户端发起其它请求 else &#123; res.setHeader('Content-Type', 'application/json'); res.redirect('/ueditor/ueditor.config.json')&#125;&#125;)); 源码 uditor:nodejs * License 注 ：转载 请注明出处 http://blog.netpi.me/nodejs/ueditor-nodejs]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo + github + 多说 来搭建免费博客]]></title>
    <url>%2F%E5%AE%9E%E7%94%A8%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo + github 搭建一个自己的博客 ! 1 要用到的模块hexo 是一款快速、简单、并且强大的博客博客模板框架 - 基于nodejs 。 github 如果你是程序员 那么github就不说了。不了解的可以点击这里github百度百科 多说 可以让你博客在没有动态服务器的情况下 ， 依然可以加入评论系统。 2 安装 hexo 生成blog2.1 安装与简单发布首先 , 我们要现在通过npm安装 hexo 1$ npm install hexo -g 安装好了之后 我们就可以初始化一个blog 并且启动服务器了 1234$ hexo init blog$ cd blog$ npm install$ hexo server 此时文件目录为 blog _config_yml // 注配置文件 db.json // 数据 debug.log // 调试日志 _node_mudules // nodejs 相关依赖 package.json // 配置依赖 scaffolds // 脚手架 - 也就是一个工具模板 source // 存放blog正文的地方 themes // 存放皮肤的地方 默认访问 http://localhost:4000 2.2 页面打不开如果你的电脑没有翻-墙 可能会打不开页面。因为页面中默认使用了ajax.google.com 下的js包。因此我们要把包删掉 解决办法： 进入你刚新建好的 blog根目录 ，进入 1themes/landscape/layout/_partial 1，找到 after-footer.ejs 把 &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt; &lt;/script&gt; 替换成 &lt;script src=&quot;http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot; &gt; &lt;/script&gt; 2，找到 header.ejs 注释掉或者删掉 下面这句css引用 &lt;link href=&quot;//fonts.googleapis.com/css?family=Source+Code+Pro&quot; rel=”stylesheet” type=”text/css”&gt; 重新 hexo server 之后。访问 http://localhost:4000 就会看到blog主页了。 2.3 新建文章当我们想写一篇blog时 在blog根目录下我们可以通过 hexo new &lt;title&gt; 指令来实现 例如我们想新建一篇主题为hello的blog 1hexo new hello 输出信息如下 1[info] File created at /Users/Night/Web/projects/java/temp/blog-test/source/_posts/hello.md hexo会在 source/_posts/ 下新建hello.md 文件。 编辑 hello.md 就是编辑你的blog内容了 – markdown语法 hello.md 的文档和目录可以这样添加123456789101112title: hexo、github、多说、搭建免费博客date: 2014-10-19 12:56:58tags:- tag1- tag2- tag3categories:- 目录__// 你的内容&lt;!--more--&gt; // 以上为摘要 2.4 静态处理因为我们的blog要部署到github静态服务器上面，所有我们还要将页面进行静态化 hexo 为我们提供了 hexo g 的方法。进入blog根目录 执行 1$ hexo g 会有如下提示信息 123456789101112131415161718192021222324252627282930[info] Files loaded in 0.081s[create] Generated: archives/index.html (48ms)[create] Generated: archives/2014/index.html (10ms)[create] Generated: archives/2014/10/index.html (7ms)[create] Generated: index.html (9ms)[create] Generated: 2014/10/19/hello-world/index.html (19ms)[create] Generated: js/script.js (5ms)[create] Generated: css/style.css (434ms)[create] Generated: css/fonts/FontAwesome.otf (1ms)[create] Generated: css/fonts/fontawesome-webfont.eot (2ms)[create] Generated: css/fonts/fontawesome-webfont.svg (2ms)[create] Generated: css/fonts/fontawesome-webfont.ttf (4ms)[create] Generated: css/fonts/fontawesome-webfont.woff (1ms)[create] Generated: css/images/banner.jpg (3ms)[create] Generated: fancybox/blank.gif (2ms)[create] Generated: fancybox/fancybox_loading.gif (1ms)[create] Generated: fancybox/fancybox_loading@2x.gif (1ms)[create] Generated: fancybox/fancybox_overlay.png (1ms)[create] Generated: fancybox/fancybox_sprite.png (0ms)[create] Generated: fancybox/fancybox_sprite@2x.png (1ms)[create] Generated: fancybox/jquery.fancybox.css (0ms)[create] Generated: fancybox/jquery.fancybox.js (1ms)[create] Generated: fancybox/jquery.fancybox.pack.js (1ms)[create] Generated: fancybox/helpers/fancybox_buttons.png (1ms)[create] Generated: fancybox/helpers/jquery.fancybox-buttons.css (1ms)[create] Generated: fancybox/helpers/jquery.fancybox-buttons.js (0ms)[create] Generated: fancybox/helpers/jquery.fancybox-media.js (1ms)[create] Generated: fancybox/helpers/jquery.fancybox-thumbs.css (2ms)[create] Generated: fancybox/helpers/jquery.fancybox-thumbs.js (1ms)[info] 28 files generated in 0.565s blog根目录下会生成public文件夹-里面就是刚才生成的静态文件 hexo 的详细实用说明请参看官方文档 3 将blog部署到 github/bae3.1 部署到github/bae部署到github 非常简单。因为hexo已经为你集成好了发布到github的配置。 我们只需要 修改 blog 目录下的 _config.yml 文件 打开 _config.yml 找到如下配置 123deploy: type: github repo: https://github.com/yourname/blog.git 修改 repo : ‘your github repo’ 回到 blog 目录 执行 1hexo deploy 你会发现public 目录下的页面已经发布到github gh-pages 分支了 往后我们要做的就是用自己的域名指向 github。 部署到bae请参考 :放弃github pages,把hexo博客部署到百度BAE吧 3.2 域名指向3.2.1 主域名指向例如 我的域名为 netpi.me 1 ，我们要在github blog项目下新建一个CNAME文件 内容为 netpi.me 2 ，将我们得域名A 记录到 207.97.227.245 这个ip 域名解析完成后我们 访问netpi.me 就是我们的blog了 3.2.2 子域名指向例如 我的域名为 blog.netpi.me 1 ，我们要在github blog项目下新建一个CNAME文件 内容为 blog.netpi.me 2 ，将我们得域名CNAME 到 ‘你的github名’.github.io (例如 netpi.github.io) 域名解析完成后我们 访问blog.netpi.me 就是我们的blog了 解析期间我们可以用1ping netpi.me 来方便的获知 解析情况。 4 插件安装4.1 多说评论插件多说为 hexo量身打造了一套解决方案 Hexo使用多说教程 站点创建地址 4.2 rssrss的安装非常简单 ，已经有人做好了插件，安装只需一步。 1npm install hexo-generator-feed 启动服务器，用浏览器打开 http://localhost:4000/atom.xml， 就可以看到RSS已经生效了。 4.2 sitemap同样是一条命令，就可以完成。 1npm install hexo-generator-sitemap 启动服务器，用浏览器打开 用浏览器打开 http://localhost:4000/sitemap.xml 发现site已经生效 License 注 ：转载 请注明出处 http://blog.netpi.me/实用/hexo]]></content>
      <categories>
        <category>实用</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>多说</tag>
      </tags>
  </entry>
</search>
