<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[放弃github pages,把hexo博客部署到百度BAE吧]]></title>
      <url>code%2Fhexo-bae-configure%2F</url>
      <content type="text"><![CDATA[让你的博客访问速度 飞起来 博客部署到Github Pages的问题在这之前我的博客一直都部署github pages下面.好处主要是因为 免费 部署起来方便快速. 但是问题却有很多比如: 访问速度略慢 不稳定 , 经常访问超时 不稳定造成 不利于seo 甚至百度不收录 解决办法 - 部署到 BAEBAE的介绍与配置 BAE官方介绍 简单来说BAE 可以提供一个支持git代码托管的静态服务器,每天只要一毛钱当前这篇博客就托管在bae下, 5Mb/s的速度绝对够用, 速度嗖嗖嗖. 创建一个BAE项目 登录 百度云控制台 开通BAE 创建一个bae项目 选择light-static | 这一步要注意,代码版本工具要选择git不要选svn 开启自动发布 回到部署列表 点击项目名称 点击发布设置 开启自动发不 安装 hexo-deployer-gitnpm install hexo-deployer-git --save 123➜ hexo-bae-demo git:(master) npm install hexo-deployer-git --savehexo-site@0.0.0 /Users/night/code/videoplusplus/github/hexo-demo/hexo-bae-demo└── hexo-deployer-git@0.2.0 配置 _config.yml编辑根目录下 _config.yml 添加1234deploy: type: git repo: https://git.duapp.com/appid970bs422df # 这是你bae项目中的git地址 获取方法如下图 部署到BAE$ hexo d 直接部署到BAE 第一次执行需要输入帐号密码 - 分别是你百度云的帐号密码 12345678910➜ hexo-bae-demo git:(master) ✗ hexo d INFO Deploying: git INFO Clearing .deploy_git folder... INFO Copying files from public folder... On branch master nothing to commit, working tree clean To https://git.duapp.com/appid970bs422df + d409e0c...af1773c HEAD -&gt; master (forced update) Branch master set up to track remote branch master from https://git.duapp.com/appid970bs422df. INFO Deploy done: git 这一步中如果是以上结果那么恭喜你成功了 如果是以下结果123456789➜ hexo-bae-demo git:(master) ✗ hexo dINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...On branch masternothing to commit, working tree cleanerror: RPC failed; HTTP 411 curl 22 The requested URL returned error: 411 Length Requiredfatal: The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedly 原因是 : 文件内容过大 解决方案如下 : 编辑 .deploy_git/.git/config 尾部加入如下代码12[http] postBuffer = 524288000 修改之后再执行 hexo d 问题解决1234567891011➜ hexo-bae-demo git:(master) ✗ vim .deploy_git/.git/config➜ hexo-bae-demo git:(master) ✗ hexo dINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...On branch masternothing to commit, working tree cleanTo https://git.duapp.com/appid970bs422df af1773c..6f2e504 HEAD -&gt; masterBranch master set up to track remote branch master from https://git.duapp.com/appid970bs422df.INFO Deploy done: git 查看结果 License 注 ：转载 请注明出处 http://www.netpi.me/code/hexo-bae-configure/ 感谢 如果这篇文章对你有帮助,请点击最上方广告一次 谢谢!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git常用的撤销操作]]></title>
      <url>uncategorized%2Fgitrevoke%2F</url>
      <content type="text"><![CDATA[Git各个状态之间转换指令总结 基本状态标识 A- = untracked 未跟踪 A = tracked 已跟踪未修改 A+ = modified - 已修改未暂存 B = staged - 已暂存未提交 C = committed - 已提交未PUSH 各状态之间变化 A- -&gt; B : git add &lt;FILE&gt; B -&gt; A- : git rm --cached &lt;FILE&gt; B -&gt; 删除不保留文件 : git rm -f &lt;FILE&gt; A -&gt; A- : git rm --cached &lt;FILE&gt; A -&gt; A+ : 修改文件 A+ -&gt; A : git checkout -- &lt;FILE&gt; A+ -&gt; B : git add &lt;FILE&gt; B -&gt; A+ : git reset HEAD &lt;FILE&gt; B -&gt; C : git commit C -&gt; B : git reset --soft HEAD^ 修改最后一次提交:git commit --amend (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https'){ bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else{ bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); })();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文字识别 baidu-ocr-nodejs]]></title>
      <url>uncategorized%2Fbaidu-ocr-nodejs%2F</url>
      <content type="text"><![CDATA[👓 Baidu OCR Api For Node Advantages 支持本地图片 外部图片(速度取决图片大小) 识别简单的验证码 平时相机拍摄书本的文字,基本能达到 95% 支持 shell/nodejs 全局安装可在控制台直接运行 bluebird/promise 接口操作灵活 Install &amp; Usage1. Global123456789npm install baidu-ocr-api -gocr --help# 远程图片ocr http://7pun4e.com1.z0.glb.clouddn.com/test.jpg# 本地图片ocr ./test.jpg 效果图 的早期世界观是建立在《魔兽争霸3：冰封王座》的基础上的，因此与现在暴雪公司的《魔兽世界》的背景设定有一定的联系，但由于版本更迭又略有不同。整个地图中地形名费伍德森林，费伍德森林是网络游戏《魔兽世界》中的游戏地图，位于卡利姆多境内的一片森林。这片由森林和草场构成的繁荣动荡的土地曾经由卡尔多雷掌管，并曾经处于半神塞纳留斯的保护下。燃烧军团的铁蹄践踏了这片土地，没有被毁灭的树木和生物则被恶魔的暴行永远的诅咒着 2. Nodejs1npm install baidu-ocr-api --save FYI examples 123456789101112131415161718/**登陆 百度bcs控制台中心 申请access keyhttps://console.bce.baidu.com/iam/#/iam/accesslist**/var ak = 'your ak';var sk = 'your sk';var ocr = require('baidu-ocr-api').create(ak,sk);// 外部图片ocr.scan(&#123; url:'http://7pun4e.com1.z0.glb.clouddn.com/test.jpg', // 支持本地路径 type:'text',&#125;).then(function (result) &#123; return console.log(result)&#125;).catch(function (err) &#123; console.log('err', err);&#125;) Test12make testmake cov # Coverage rate License MIT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最快捷 PokemonGo 安装教程 - 解决了锁区问题]]></title>
      <url>iOS%2FPokemonGo%2F</url>
      <content type="text"><![CDATA[为了方便大家安装 , 我们破解了 PokemonGo 解决了锁区问题 让国内的玩家也可以抓小怪兽了 1 安装在safari中打开: http://fir.im/ey57 点击安装PokemonGo 2 解决 : 未受信任的企业开发者设置 –&gt; 通用 –&gt; 描述文件与设备管理 –&gt; 信任 3 登录打开PokemonGo 用Google登录, 第一次登录需要vpn翻墙.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dota2 Api nodejs]]></title>
      <url>nodejs%2FDota2-Api-nodejs%2F</url>
      <content type="text"><![CDATA[利用api调用 Dota2 英雄比赛数据a node-plugin for dota2 ;github 源码地址 GETTING A KEYFirst off get a dev key from here, http://steamcommunity.com/dev/apikey and login with your Steam account and you will get unique key. Installation1npm install dota --save Usage1234567891011121314151617181920var Dota2Api = require('dota').dota2api;var key = 'your key'; //Your personal API key (from above)var language = 'zh_CN';// The language to retrieve results in (default is en_us) (see http://en.wikipedia.org/wiki/ISO_639-1 for the language codes (first two characters) and http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes for the country codes (last two characters))var format = 'JSON' The format to retrieve results in ("JSON" or "XML")var dota2api = new Dota2Api(key,language,format)var config=&#123; account_id : '232210304', matches_requested : 10&#125;// to get the latest 10 matches played by person whth 32-bit ID 232210304dota2api.getMatchHistory(config,function(err,data)&#123; if(err)&#123; throw err; &#125;else&#123; // you will get the result console.log(data); &#125;&#125;); About ApigetMatchHistory()sed to get a list of matches played. Available Options1234567891011var config &#123; hero_id: &lt; id &gt; , // Search for matches with a specific hero being played (hero ID, not name, see HEROES below) game_mode: &lt; mode &gt; , // Search for matches of a given mode (see below) skill: &lt; skill &gt; , // 0 for any, 1 for normal, 2 for high, 3 for very high skill (default is 0) min_players: &lt; count &gt; , // the minimum number of players required in the match account_id: &lt; id &gt; , // Search for all matches for the given user (32-bit or 64-bit steam ID) league_id: &lt; id &gt; , // matches for a particular league start_at_match_id: &lt; id &gt; , // Start the search at the indicated match id, descending matches_requested: &lt; n &gt; , // Maximum is 25 matches (default is 25) tournament_games_only: &lt; string &gt; // set to only show tournament games&#125; 12345678dota2api.getMatchHistory(config, function(err, data) &#123; if (err) &#123; throw err; &#125; else &#123; // you will get the result console.log(data); &#125;&#125;) getMatchDetails()Used to get detailed information about a specified match. Available options:123var config=&#123; match_id=&lt;id&gt; // the match's ID&#125; 12345678dota2api.getMatchDetails(config, function(err, data) &#123; if (err) &#123; throw err; &#125; else &#123; // you will get the result console.log(data); &#125;&#125;) getHeroes()Used to get an UP-TO-DATE list of heroes. Available Options12345var config=&#123; // nothing ... language:'en' // you can also set language just for this request format : 'XML' // you can also set format just for this request&#125; Result Field Format: heroes - an array of the heroes: name - the hero’s in-game “code name” id - the hero’s numeric ID localized_name - the hero’s text name (language specific result - this field is not present if no language is specified) count - the total number of heroes in the list 12345678dota2api.getHeroes(config, function(err, data) &#123; if (err) &#123; throw err; &#125; else &#123; // you will get the result console.log(data); &#125; &#125;) getLeagueListing()Used to get a list of the tournament leagues that are available for viewing in the client (i.e. you can buy a ticket to them).Intended for use in conjunction with GetLiveLeagueGames. Available Options12345var config=&#123; // nothing ... language:'en' // you can also set language just for this request format : 'XML' // you can also set format just for this request&#125; 12345678dota2api.getLeagueListing(config, function(err, data) &#123; if (err) &#123; throw err; &#125; else &#123; // you will get the result console.log(data); &#125; &#125;) getLiveLeagueGames()Used to get a list of the tournament leagues that are available for viewing in the client (i.e. you can buy a ticket to them).Intended for use in conjunction with GetLiveLeagueGames. Available OptionsCommon options only (see above) - Note that if no language is specified, the API will return the in-game “string” placeholders for all fields marked with (language specific). Result Field Format: leagues - an array of the leagues: name - the league’s full name (language specific) leagueid - the league’s numeric ID escription - a description of the leauge (language specific) tournament_url - the url of the tournament’s home page 12345678dota2api.getLiveLeagueGames(config, function(err, data) &#123; if (err) &#123; throw err; &#125; else &#123; // you will get the result console.log(data); &#125; &#125;) getMatchHistoryBySequenceNum()Used to get the matches in the order which they were recorded (i.e. sorted ascending by match_seq_num).This means that the first match on the first page of results returned by the call will be the very first public mm-match recorded in the stats. 123456789101112var config=&#123; start_at_match_seq_num=&lt;id&gt;, matches_requested=&lt;n&gt;&#125;dota2api.getMatchHistoryBySequenceNum(config, function(err, data) &#123; if (err) &#123; throw err; &#125; else &#123; // you will get the result console.log(data); &#125; &#125;) TEST1make test LicenseThe MIT license]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx 安装 启动 停止 重启]]></title>
      <url>nginx%2Fnginx-conf%2F</url>
      <content type="text"><![CDATA[Nigix 安装 使用 配置 0 安装1234sudo apt-get install software-properties-commonsudo add-apt-repository ppa:nginx/stablesudo apt-get updatesudo apt-get install nginx 2 启动,停止,重启1nginx -s signal signal 的内容如下1234stop — 快速停止quit — 优雅的停止reload — 重启reopen — 重新打开日志文件 3 关于配置文件2.1 配置文件简单说明配置文件可以看做是Nginx的灵魂，Nginx服务在启动时会读入配置文件，而后续几乎一切动作行为都是按照配置文件中的指令进行的，因此如果将Nginx本身看做一个计算机，那么Nginx的配置文件可以看成是全部的程序指令。 Nginx配置文件是纯文本文件，你可以用任何文本编辑器如vim或emacs打开它，通常它会在nginx安装目录的conf下 其中“#”表示此行是注释，由于笔者为了学习扩展开发安装了一个纯净的Nginx，因此配置文件没有经过太多改动。 Nginx的配置文件是以block的形式组织的，一个block通常使用大括号“{}”表示。block分为几个层级，整个配置文件为main层级，这是最大的层级；在main层级下可以有event、http等层级，而http中又会有server block，server block中可以包含location block。 每个层级可以有自己的指令（Directive），例如worker_processes是一个main层级指令，它指定Nginx服务的Worker进程数量。有的指令只能在一个层级中配置，如worker_processes只能存在于main中，而有的指令可以存在于多个层级，在这种情况下，子block会继承父block的配置，同时如果子block配置了与父block不同的指令，则会覆盖掉父block的配置。指令的格式是“指令名 参数1 参数2 … 参数N;”，注意参数间可用任意数量空格分隔，最后要加分号。 在开发Nginx HTTP扩展模块过程中，需要特别注意的是main、server和location三个层级，因为扩展模块通常允许指定新的配置指令在这三个层级中。 一般来说，一个server block表示一个Host，而里面的一个location则代表一个路由映射规则，这两个block可以说是HTTP配置的核心。配置文件 下图是Nginx配置文件通常结构图示。 2.2 主模块 控制 Nginx 的基本功能的指令. 2.2.1 daemon语法: daemon on | off 默认值: on 1daemon off; 生产环境中不要使用”daemon”和”master_process”指令，这些选项仅用于开发调试。 2.2.2 debug_points语法: debug_points [stop | abort] 默认值: none 1debug_points stop; 2.2.3 error_log语法: error_log file [ debug | info | notice | warn | error | crit ] 默认值: ${prefix}/logs/error.log Nginx 添加 –with-debug 编译参数, 你还能够使用以下配置: 12error_log LOGFILE [ debug_core | debug_alloc | debug_mutex | debug_event]: | debug_http | debug_imap ; 2.2.4 include语法: include file | * 默认值: none 你可以在任意地方使用include指令实现配置文件的包含，类似于apache中的include方法，可减少主配置文件d。 include 指令还支持像下面配置一样的全局包含的方法，例如包含一个目录下所有以”.conf”结尾的文件:1include vhosts/*.conf; 注意路径受到configure编译参数–prefix=&lt;路径&gt;指令的影响，如果没有指定，Nginx默认是被编译在/usr/local/nginx。 语法: lock_file file 默认值: compile-time option1lock_file /var/log/lock_file; 2.2.5 master_process语法: master_process on | off 默认值: on1master_process off; 生产环境中不要使用”daemon”和”master_process”指令，这些选项仅用于开发调试。 2.2.6 pid语法: pid file 默认值: compile-time option Example: 1pid /var/log/nginx.pid; 进程id存储文件。可以使用 kill -HUP cat /var/log/nginx.pid\ 对Nginx进行配置文件重新加载。 2.2.7 ssl_engine语法: ssl_engine engine 默认值: system dependent 该指令用于指定openssl使用的引擎。你可以通过下面的命令行获知系统目前支持的openssl引擎 openssl engine -t 例如 :12345$ openssl engine -t(cryptodev) BSD cryptodev engine: [ available ](dynamic) Dynamic engine loading support: [ unavailable ] 2.2.8 timer_resolution语法: timer_resolution t 默认值: none Example:1timer_resolution 100ms; 官方文档的说明: The directive allows to decrease number gettimeofday() syscalls. By default gettimeofday() is called after each return from kevent(), epoll, /dev/poll, select(), poll(). But if you need an exact time in logs when logging $upstream_response_time, or $msec variables, then you should use timer_resolution. 2.2.9 user语法: user user [group] 默认值: nobody nobody 指定Nginx Worker进程运行用户，默认是nobody帐号。 例如: 1user www users; 2.2.10 worker_cpu_affinity语法: worker_cpu_affinity cpumask [cpumask…] 默认值: none Linux only. With this option you can bind the worker process to a CPU, it calls sched_setaffinity(). 仅适用于linux，使用该选项可以绑定worker进程和CPU. e.g.:12worker_proceses 4;worker_cpu_affinity 0001 0010 0100 1000; Bind each worker process to one CPU only. 分别给每个worker进程绑定一个CPU. 12worker_proceses 2;worker_cpu_affinity 0101 1010; Bind the first worker to CPU0/CPU2, bind the second worker to CPU1/CPU3. This is suitable for HTT. 将CPU0/CPU2绑定给第一个worker进程，将CPU1/CPU3绑定给第二个worker进程。 2.2.11 worker_priority语法: worker_priority [-] number 默认值: on With this option you can give to all worker processes the priority (nice) you need/wish, it calls setpriority(). 使用该选项可以给所有的worker进程分配优先值。 2.2.12 worker_processes语法: worker_processes number 默认值: 1 e.g.: 1worker_processes 5; nginx has the ability to use more than one worker process for several reasons: nginx可以使用多个worker进程，原因如下： 1.to use SMP 2.to decrease latency when workers blockend on disk I/O 3.to limit number of connections per process when select()/poll() is used The worker_processes and worker_connections from the event sections allows you to calculate maxclients value: k max_clients = worker_processes * worker_connections 2.2.13 worker_rlimit_core语法: worker_rlimit_core size 默认值: ‘ Maximum size of core file per worker; 2.2.14 worker_rlimit_nofile语法: worker_rlimit_nofile limit 默认值: ‘ Specifies the value for maximum file descriptors that can be opened by this process. 指定 2.2.15 worker_rlimit_sigpending语法: worker_rlimit_sigpending limit 默认值: ‘ (Since Linux 2.6.8) Specifies the limit on the number of signals that may be queued for the real user ID of the calling process. 2.2.16 working_directory语法: working_directory path 默认值: –prefix This is the working directory for the workers. It’s used for core files only. nginx uses absolute paths only, all relative paths in configuration files are relative to –prefix==PATH. 2.3 事件模块 设置Nginx处理连接请求e.g.:123events &#123; worker_connections 1024;&#125; 2.3.1 accept_mutexSyntax: accept_mutex [ on | off ] Default: on nginx 使用连接互斥锁进行顺序的accept()系统调用. 2.3.2 accept_mutex_delaySyntax: accept_mutex_delay Nms; Default: 500ms 如果一个进程没有互斥锁，它将延迟至少多长时间。默认情况下，延迟是500ms 。 2.3.3 useSyntax: use [ kqueue | rtsig | epoll | /dev/poll | select | poll | eventport ] Default: 如果在./configure的时候指定了不止一种事件模型，那么可以设置其中一个，以便告诉nginx使用哪种事件模型。默认情况下nginx会在./configure时找出最适合系统的事件模型。 你可以在 这里 查看可用的事件模型以及如何在./configure时激活 2.3.4 worker_connectionsSyntax: worker_connections number Default: 通过worker_connections和worker_proceses可以计算出maxclients：1max_clients = worker_processes * worker_connections 作为反向代理，max_clients为：1max_clients = worker_processes * worker_connections/4 Since a browser opens 2 connections by default to a server and nginx uses the fds (file descriptors) from the same pool to connect to the upstream backend 注 ：转载 请注明出处 http://blog.netpi.me/nginx/nginx-conf/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ueditor:nodejs]]></title>
      <url>nodejs%2Fueditor-nodejs%2F</url>
      <content type="text"><![CDATA[UEditor 官方支持的版本有PHP JSP ASP .NET.ueditor for nodejs 可以让你的UEditor支持nodejs ueditor@1.0.0 已经全面升级 。github地址 ##Installation 1npm install ueditor --save ##Usage 1234567891011121314151617181920212223242526272829303132333435363738var bodyParser = require('body-parser')var ueditor = require("ueditor")app.use(bodyParser.urlencoded(&#123; extended: true&#125;))app.use(bodyParser.json());// /ueditor 入口地址配置 https://github.com/fex-team/ueditor/blob/dev-1.5.0/ueditor.config.js// 官方例子是这样的 serverUrl: URL + "php/controller.php"// 我们要把它改成 serverUrl: URLapp.use("/ueditor", ueditor(path.join(__dirname, 'public'), function(req, res, next) &#123; // ueditor 客户发起上传图片请求 if(req.query.action === 'uploadimage')&#123; // 这里你可以获得上传图片的信息 var foo = req.ueditor; console.log(foo.filename); // exp.png console.log(foo.encoding); // 7bit console.log(foo.mimetype); // image/png // 下面填写你要把图片保存到的路径 （ 以 path.join(__dirname, 'public') 作为根路径） var img_url = 'yourpath'; res.ue_up(img_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 &#125; // 客户端发起图片列表请求 else if (req.query.action === 'listimage')&#123; var dir_url = 'your img_dir'; // 要展示给客户端的文件夹路径 res.ue_list(dir_url) // 客户端会列出 dir_url 目录下的所有图片 &#125; // 客户端发起其它请求 else &#123; res.setHeader('Content-Type', 'application/json'); // 这里填写 ueditor.config.json 这个文件的路径 res.redirect('/ueditor/ueditor.config.json&#125;&#125;)); ##Example12345678910111213141516171819202122232425262728var bodyParser = require('body-parser')var ueditor = require("ueditor")app.use(bodyParser.urlencoded(&#123; extended: true&#125;))app.use(bodyParser.json());app.use("/ueditor", ueditor(path.join(__dirname, 'public'), function(req, res, next) &#123; // ueditor 客户发起上传图片请求 if(req.query.action === 'uploadimage')&#123; var foo = req.ueditor; var date = new Data(); var imgname = req.ueditor.filename; var img_url = '/images/ueditor/'; res.ue_up(img_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 &#125; // 客户端发起图片列表请求 else if (req.query.action === 'listimage')&#123; var dir_url = '/images/ueditor/'; res.ue_list(dir_url); // 客户端会列出 dir_url 目录下的所有图片 &#125; // 客户端发起其它请求 else &#123; res.setHeader('Content-Type', 'application/json'); res.redirect('/ueditor/ueditor.config.json')&#125;&#125;)); 源码 uditor:nodejs * License 注 ：转载 请注明出处 http://blog.netpi.me/nodejs/ueditor-nodejs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装 Nginx 服务器]]></title>
      <url>nginx%2Fnginx-Installation%2F</url>
      <content type="text"><![CDATA[Nginx 安装 1 ,安装前准备安装nginx之前我们通过 yum 安装两个软件 1 pcre - 为了有rewrite功能， 1# yum install pcre 2 openssl - 为了支持ssl 1# yum install openssl 2 ,安装Nginx2.1 下载 Nginx我们用wget下载1.6.2 稳定版 1wget http://nginx.org/download/nginx-1.6.2.tar.gz 2.2 解压并且安装下载完成之后 解压文件 1tar xvf nginx-1.6.2.tar.gz 解压完成之后 , 开始编译安装1234567# cd nginx-1.6.2# ./configure --prefix=/usr/local/nginx-1.6.2 \--with-http_ssl_module --with-http_spdy_module \--with-http_stub_status_module --with-pcre 1make 1make install 2.2.1 安装过程中常见错误11./configure: error: the HTTP rewrite module requires the PCRE library. 那么我们要安装pcre-devel来解决问题 1# yum -y install pcre-deve 2.2.2 安装过程中常见错误 212345/configure: error: the HTTP cache module requires md5 functionsfrom OpenSSL library. You can either disable the module by using--without-http-cache option, or install the OpenSSL library into the system,or build the OpenSSL library statically from the source with nginx by using--with-http_ssl_module --with-openssl=&lt;path&gt; options. 解决办法 1yum -y install openssl openssl-devel 2.3 启动Nginx123/usr/local/nginx-1.6.2/sbin/nginxcurl http://localhost 发现Nginx 服务已经正常启动 : ) License 注 ：转载 请注明出处 http://blog.netpi.me/nginx/nginx-Installation/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[鱼丸豆角]]></title>
      <url>cook%2Fbean-fish%2F</url>
      <content type="text"><![CDATA[给你做一份鱼丸豆角吃吧前几天去餐厅吃自助餐 ，本想甩开膀子 大干一场，把成本吃回来。 结果半路杀出一盘 豆角 奇妙的味道 让我根本停不下来，当然结局很惨 - 白嘴吃豆角 。饱了！最后看着满桌螃蟹、牛排吃不下。我靠 ！！！ 今天我就尝试让那个味道重现 来一道《鱼丸豆角》 1，食材食材很简单 1.1 主料1 鱼丸 、小火腿 （共150g）2 豇豆 （350g 就是没有筋的那种豆角） 1.2 辅料辅料 ：八角 、花椒 、姜片、红辣椒、大蒜 、花生油 、十三香 、鸡精 、食言 、红油（辣椒油） 2，开始豆角洗净 切成3厘米左右长度 备用 因为买的是冷冻的鱼丸 所以要先放水里解冻 ###2.1 豆角腌制 这道菜的关键就是如何让花椒和八角的味道融入豆角当中。 1，首先 制作腌制的汁料 锅内加油，油热之后将切好的姜片、花椒、八角、大蒜、红辣椒 放入锅内爆炒至 飘香 2，然后将热油倒进豆角，开始腌制1个小时 期间可以把鱼丸火腿洗净切开 备用 ###2.2 下锅爆炒 腌制好了之后，就开始下锅炒了 锅内加入少许的油 ，十三香 、大蒜 。然后将腌制好的豆角全部倒入锅内爆炒（起码10分钟） 爆炒至豆角 有皱皱的感觉 ，加入鱼丸、香肠，继续爆炒，并且添加适量的食盐（大概5分钟） 爆炒至已经有某些鱼丸底部 变硬变黄 ； 关火，加鸡精、红油、香油 。翻炒出锅 整个厨房都飘着香味！吃起来味道么，恩，你做了就知道 ！！！ * License 注 ：转载 请注明出处 http://blog.netpi.me/cook/bean-fish]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo + github + 多说 来搭建免费博客]]></title>
      <url>%E5%AE%9E%E7%94%A8%2Fhexo%2F</url>
      <content type="text"><![CDATA[hexo + github 搭建一个自己的博客 ! 1 要用到的模块hexo 是一款快速、简单、并且强大的博客博客模板框架 - 基于nodejs 。 github 如果你是程序员 那么github就不说了。不了解的可以点击这里github百度百科 多说 可以让你博客在没有动态服务器的情况下 ， 依然可以加入评论系统。 2 安装 hexo 生成blog2.1 安装与简单发布首先 , 我们要现在通过npm安装 hexo 1$ npm install hexo -g 安装好了之后 我们就可以初始化一个blog 并且启动服务器了 1234$ hexo init blog$ cd blog$ npm install$ hexo server 此时文件目录为 blog _config_yml // 注配置文件 db.json // 数据 debug.log // 调试日志 _node_mudules // nodejs 相关依赖 package.json // 配置依赖 scaffolds // 脚手架 - 也就是一个工具模板 source // 存放blog正文的地方 themes // 存放皮肤的地方 默认访问 http://localhost:4000 2.2 页面打不开如果你的电脑没有翻-墙 可能会打不开页面。因为页面中默认使用了ajax.google.com 下的js包。因此我们要把包删掉 解决办法： 进入你刚新建好的 blog根目录 ，进入 1themes/landscape/layout/_partial 1，找到 after-footer.ejs 把 &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt; &lt;/script&gt; 替换成 &lt;script src=&quot;http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ &gt; &lt;/script&gt; 2，找到 header.ejs 注释掉或者删掉 下面这句css引用 &lt;link href=&quot;//fonts.googleapis.com/css?family=Source+Code+Pro&quot; rel=”stylesheet” type=”text/css”&gt; 重新 hexo server 之后。访问 http://localhost:4000 就会看到blog主页了。 2.3 新建文章当我们想写一篇blog时 在blog根目录下我们可以通过 hexo new &lt;title&gt; 指令来实现 例如我们想新建一篇主题为hello的blog 1hexo new hello 输出信息如下 1[info] File created at /Users/Night/Web/projects/java/temp/blog-test/source/_posts/hello.md hexo会在 source/_posts/ 下新建hello.md 文件。 编辑 hello.md 就是编辑你的blog内容了 – markdown语法 hello.md 的文档和目录可以这样添加123456789101112title: hexo、github、多说、搭建免费博客date: 2014-10-19 12:56:58tags:- tag1- tag2- tag3categories:- 目录__// 你的内容&lt;!--more--&gt; // 以上为摘要 2.4 静态处理因为我们的blog要部署到github静态服务器上面，所有我们还要将页面进行静态化 hexo 为我们提供了 hexo g 的方法。进入blog根目录 执行 1$ hexo g 会有如下提示信息 123456789101112131415161718192021222324252627282930[info] Files loaded in 0.081s[create] Generated: archives/index.html (48ms)[create] Generated: archives/2014/index.html (10ms)[create] Generated: archives/2014/10/index.html (7ms)[create] Generated: index.html (9ms)[create] Generated: 2014/10/19/hello-world/index.html (19ms)[create] Generated: js/script.js (5ms)[create] Generated: css/style.css (434ms)[create] Generated: css/fonts/FontAwesome.otf (1ms)[create] Generated: css/fonts/fontawesome-webfont.eot (2ms)[create] Generated: css/fonts/fontawesome-webfont.svg (2ms)[create] Generated: css/fonts/fontawesome-webfont.ttf (4ms)[create] Generated: css/fonts/fontawesome-webfont.woff (1ms)[create] Generated: css/images/banner.jpg (3ms)[create] Generated: fancybox/blank.gif (2ms)[create] Generated: fancybox/fancybox_loading.gif (1ms)[create] Generated: fancybox/fancybox_loading@2x.gif (1ms)[create] Generated: fancybox/fancybox_overlay.png (1ms)[create] Generated: fancybox/fancybox_sprite.png (0ms)[create] Generated: fancybox/fancybox_sprite@2x.png (1ms)[create] Generated: fancybox/jquery.fancybox.css (0ms)[create] Generated: fancybox/jquery.fancybox.js (1ms)[create] Generated: fancybox/jquery.fancybox.pack.js (1ms)[create] Generated: fancybox/helpers/fancybox_buttons.png (1ms)[create] Generated: fancybox/helpers/jquery.fancybox-buttons.css (1ms)[create] Generated: fancybox/helpers/jquery.fancybox-buttons.js (0ms)[create] Generated: fancybox/helpers/jquery.fancybox-media.js (1ms)[create] Generated: fancybox/helpers/jquery.fancybox-thumbs.css (2ms)[create] Generated: fancybox/helpers/jquery.fancybox-thumbs.js (1ms)[info] 28 files generated in 0.565s blog根目录下会生成public文件夹-里面就是刚才生成的静态文件 hexo 的详细实用说明请参看官方文档 3 将blog部署到 github/bae3.1 部署到github/bae部署到github 非常简单。因为hexo已经为你集成好了发布到github的配置。 我们只需要 修改 blog 目录下的 _config.yml 文件 打开 _config.yml 找到如下配置 123deploy: type: github repo: https://github.com/yourname/blog.git 修改 repo : ‘your github repo’ 回到 blog 目录 执行 1hexo deploy 你会发现public 目录下的页面已经发布到github gh-pages 分支了 往后我们要做的就是用自己的域名指向 github。 部署到bae请参考 :放弃github pages,把hexo博客部署到百度BAE吧 3.2 域名指向3.2.1 主域名指向例如 我的域名为 netpi.me 1 ，我们要在github blog项目下新建一个CNAME文件 内容为 netpi.me 2 ，将我们得域名A 记录到 207.97.227.245 这个ip 域名解析完成后我们 访问netpi.me 就是我们的blog了 3.2.2 子域名指向例如 我的域名为 blog.netpi.me 1 ，我们要在github blog项目下新建一个CNAME文件 内容为 blog.netpi.me 2 ，将我们得域名CNAME 到 ‘你的github名’.github.io (例如 netpi.github.io) 域名解析完成后我们 访问blog.netpi.me 就是我们的blog了 解析期间我们可以用1ping netpi.me 来方便的获知 解析情况。 4 插件安装4.1 多说评论插件多说为 hexo量身打造了一套解决方案 Hexo使用多说教程 站点创建地址 4.2 rssrss的安装非常简单 ，已经有人做好了插件，安装只需一步。 1npm install hexo-generator-feed 启动服务器，用浏览器打开 http://localhost:4000/atom.xml， 就可以看到RSS已经生效了。 4.2 sitemap同样是一条命令，就可以完成。 1npm install hexo-generator-sitemap 启动服务器，用浏览器打开 用浏览器打开 http://localhost:4000/sitemap.xml 发现site已经生效 License 注 ：转载 请注明出处 http://blog.netpi.me/实用/hexo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Blog init]]></title>
      <url>%E6%97%B6%E9%97%B4%2Fhello-world-1%2F</url>
      <content type="text"><![CDATA[人生需要折腾 忙活了一整天 blog终于算是完成了吧 ！hexo + 多说 + github 。免费搭建可以评论的blog系统 感觉很酷。 github 300M的免费空间速度还是能接受滴，也不会觉得很卡拉 。 多说 这个评论插件真的太给力 天亮… 6点了 ，这一晚真上没白忙活呀 。刚才又加入了百度统计，rss订阅。暂时先这样，碎觉了 ！]]></content>
    </entry>

    
  
  
</search>
